import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
from datetime import datetime, timedelta
from texts.request import TextsRequest
from dictionary.vars import PLATFORMS


class Dashboard:
    """
    Classe respons√°vel pelo dashboard com estat√≠sticas e gr√°ficos dos textos.
    """

    def __init__(self):
        pass

    def format_br_date(self, date_str):
        """Converte data para formato brasileiro."""
        if date_str and len(date_str) >= 10:
            try:
                date_obj = datetime.strptime(date_str[:10], '%Y-%m-%d')
                return date_obj.strftime('%d/%m/%Y')
            except BaseException:
                return date_str[:10]
        return 'N/A'

    def main_menu(self, token, permissions):
        """
        Exibe o dashboard principal com estat√≠sticas e gr√°ficos.

        Parameters
        ----------
        token : str
            Token de autentica√ß√£o do usu√°rio
        permissions : list
            Lista de permiss√µes do usu√°rio
        """
        # Verificar se √© superusu√°rio (admin)
        from api.token import Token
        user_data = Token().get_user_permissions(token)
        is_superuser = user_data.get(
            'is_superuser', False) if user_data else False

        if is_superuser:
            st.markdown("""
            <div style="text-align: center; padding: 50px;
                background: #f8d7da; border-radius: 15px;
                border: 1px solid #f5c6cb;">
                <h3 style="color: #721c24;">
                    ‚ö†Ô∏è Acesso Restrito para Superusu√°rio
                </h3>
                <p style="color: #721c24; font-size: 1.1rem;">
                    O dashboard n√£o est√° dispon√≠vel para superusu√°rios.<br>
                    Esta funcionalidade √© destinada apenas aos usu√°rios
                        regulares<br>
                    que trabalham diretamente com a gera√ß√£o de textos.
                </p>
            </div>
            """, unsafe_allow_html=True)
            return

        # Verificar se tem permiss√µes de texto usando formato Django
        django_text_permissions = [
            'texts.add_text',
            'texts.view_text',
            'texts.change_text',
            'texts.delete_text'
        ]
        has_text_permission = any(
            perm in permissions for perm in django_text_permissions)

        if not has_text_permission:
            st.markdown("""
            <div style="text-align: center; padding: 50px;
                background: #fff3cd; border-radius: 15px;
                border: 1px solid #ffeaa7;">
                <h3 style="color: #856404;">üîí Acesso Restrito</h3>
                <p style="color: #856404; font-size: 1.1rem;">
                    Voc√™ n√£o possui permiss√µes relacionadas aos textos.<br>
                    O dashboard est√° dispon√≠vel apenas para usu√°rios<br>
                    com permiss√µes de texto (ler, criar, editar ou excluir).
                    <br>
                <br>
                    Entre em contato com o administrador do sistema.
                </p>
            </div>
            """, unsafe_allow_html=True)
            return

        st.markdown("""
        <div style="text-align: center; padding: 20px 0;">
            <h1 style="color: #1f77b4;">üìä Dashboard</h1>
        </div>
        """, unsafe_allow_html=True)

        st.divider()

        texts = TextsRequest().get_texts(token)

        if not texts:
            st.markdown("""
            <div style="text-align: center; padding: 50px;
                background: #f8f9fa; border-radius: 15px;
                border: 2px dashed #dee2e6;">
                <h3 style="color: #6c757d;">üìÑ Nenhum texto encontrado</h3>
                <p style="color: #6c757d; font-size: 1.1rem;">
                    Ainda n√£o h√° textos para gerar estat√≠sticas.<br>
                    Que tal gerar seu primeiro texto usando IA?
                </p>
            </div>
            """, unsafe_allow_html=True)
            return

        # Preparar dados para an√°lise
        df = pd.DataFrame(texts)

        # Adicionar colunas processadas
        df['created_date'] = pd.to_datetime(df['created_at'].str[:10])
        df['month_year'] = df['created_date'].dt.to_period('M').astype(str)
        df['platform_name'] = df['platform'].map(PLATFORMS)
        df['status_text'] = df['is_approved'].map(
            {
                True: 'Aprovado',
                False: 'Pendente'
            }
        )

        # M√©tricas principais
        st.markdown("### üìà M√©tricas Gerais")

        col1, col2, col3, col4 = st.columns(4)

        total_texts = len(texts)
        pending_texts = len(
            [t for t in texts if not t.get('is_approved', False)])
        approved_texts = len([t for t in texts if t.get('is_approved', False)])
        platforms_count = len(df['platform'].unique())

        with col1:
            st.metric("üìù Total de Textos", total_texts)
        with col2:
            st.metric(
                "‚è≥ Pendentes",
                pending_texts,
                delta=f"{(pending_texts / total_texts * 100):.1f}%" if (
                    total_texts > 0
                ) else "0%"
            )
        with col3:
            st.metric(
                "‚úÖ Aprovados",
                approved_texts,
                delta=f"{(approved_texts / total_texts * 100):.1f}%" if (
                    total_texts > 0
                ) else "0%"
            )
        with col4:
            st.metric("üåê Plataformas", platforms_count)

        st.divider()

        # Gr√°ficos em duas colunas
        col_left, col_right = st.columns(2)

        with col_left:
            # Gr√°fico de status (pizza)
            st.markdown("### üìä Status dos Textos")
            status_data = df['status_text'].value_counts()

            fig_status = px.pie(
                values=status_data.values,
                names=status_data.index,
                title="Distribui√ß√£o por Status",
                color_discrete_map={
                    'Aprovado': '#28a745',
                    'Pendente': '#ffc107'
                }
            )
            fig_status.update_layout(height=400)
            st.plotly_chart(fig_status, use_container_width=True)

        with col_right:
            # Gr√°fico de plataformas (barras)
            st.markdown("### üåê Textos por Plataforma")
            platform_data = df['platform_name'].value_counts()

            fig_platform = px.bar(
                x=platform_data.index,
                y=platform_data.values,
                title="Quantidade por Plataforma",
                color=platform_data.values,
                color_continuous_scale="viridis"
            )
            fig_platform.update_layout(
                height=400,
                xaxis_title="Plataforma",
                yaxis_title="Quantidade",
                showlegend=False
            )
            fig_platform.update_layout(xaxis_tickangle=45)
            st.plotly_chart(fig_platform, use_container_width=True)

        # Gr√°fico de linha temporal
        st.markdown("### üìÖ Evolu√ß√£o Temporal")

        # Agrupar por m√™s
        monthly_data = df.groupby(
            ['month_year', 'status_text']).size().unstack(fill_value=0)

        fig_timeline = go.Figure()

        if 'Aprovado' in monthly_data.columns:
            fig_timeline.add_trace(
                go.Scatter(
                    x=monthly_data.index,
                    y=monthly_data['Aprovado'],
                    mode='lines+markers',
                    name='Aprovados',
                    line=dict(color='#28a745', width=3),
                    marker=dict(size=8)
                )
            )

        if 'Pendente' in monthly_data.columns:
            fig_timeline.add_trace(
                go.Scatter(
                    x=monthly_data.index,
                    y=monthly_data['Pendente'],
                    mode='lines+markers',
                    name='Pendentes',
                    line=dict(color='#ffc107', width=3),
                    marker=dict(size=8)
                )
            )

        fig_timeline.update_layout(
            title="Textos Criados por M√™s",
            xaxis_title="Per√≠odo",
            yaxis_title="Quantidade de Textos",
            height=400,
            hovermode='x unified'
        )

        st.plotly_chart(fig_timeline, use_container_width=True)

        st.divider()

        # Tabela resumo detalhada
        st.markdown("### üìã Resumo Detalhado")

        col_table1, col_table2 = st.columns(2)

        with col_table1:
            st.markdown("#### Por Plataforma")
            platform_summary = df.groupby('platform_name').agg({
                'id': 'count',
                'is_approved': lambda x: sum(x),
            }).rename(columns={'id': 'Total', 'is_approved': 'Aprovados'})
            platform_summary['Pendentes'] = platform_summary['Total'] - \
                platform_summary['Aprovados']
            platform_summary['Taxa Aprova√ß√£o'] = (
                platform_summary['Aprovados'] / platform_summary['Total'] * 100
            ).round(1).astype(str) + '%'

            st.dataframe(platform_summary, use_container_width=True)

        with col_table2:
            st.markdown("#### Por Per√≠odo")
            monthly_summary = df.groupby('month_year').agg({
                'id': 'count',
                'is_approved': lambda x: sum(x),
            }).rename(columns={'id': 'Total', 'is_approved': 'Aprovados'})
            monthly_summary['Pendentes'] = monthly_summary['Total'] - \
                monthly_summary['Aprovados']
            monthly_summary = monthly_summary.sort_index(
                ascending=False).head(6)  # √öltimos 6 meses

            st.dataframe(monthly_summary, use_container_width=True)

        # Insights autom√°ticos
        st.markdown("### üí° Insights")

        insights_col1, insights_col2 = st.columns(2)

        with insights_col1:
            # Plataforma mais utilizada
            top_platform = platform_data.index[0] if len(
                platform_data) > 0 else "N/A"
            top_platform_count = platform_data.iloc[0] if len(
                platform_data) > 0 else 0

            st.info(
                f"""üèÜ **Plataforma mais utilizada:** {
                    top_platform
                } ({top_platform_count} textos)""")

            # Taxa de aprova√ß√£o
            approval_rate = (
                approved_texts /
                total_texts *
                100) if total_texts > 0 else 0
            if approval_rate >= 80:
                st.success(
                    f"‚úÖ **Excelente taxa de aprova√ß√£o:** {approval_rate:.1f}%")
            elif approval_rate >= 60:
                st.warning(
                    f"‚ö†Ô∏è **Taxa de aprova√ß√£o moderada:** {approval_rate:.1f}%")
            else:
                st.error(
                    f"‚ö†Ô∏è **Taxa de aprova√ß√£o baixa:** {approval_rate:.1f}%")

        with insights_col2:
            # Textos criados nos √∫ltimos 7 dias
            last_week = datetime.now() - timedelta(days=7)
            recent_texts = len([t for t in texts if datetime.strptime(
                t['created_at'][:10], '%Y-%m-%d') >= last_week])

            if recent_texts > 0:
                st.info(
                    f"üìà **Textos criados na √∫ltima semana:** {recent_texts}")
            else:
                st.info("üìä **Nenhum texto criado na √∫ltima semana**")

            # M√©dia de textos por m√™s
            if len(monthly_data) > 0:
                avg_per_month = total_texts / len(monthly_data)
                st.info(f"üìÖ **M√©dia por m√™s:** {int(avg_per_month)} textos")
